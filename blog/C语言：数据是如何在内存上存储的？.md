# C语言：数据是如何在内存上存储的？

我们学习C语言的时候有没有这样的疑惑呢？我想大家也听说过，计算机是以二进制进行存储的（存储在内存上），也就是1和0。那我们一起来看一下，数据到底是怎么存储。

## 我们今天讲解的重点有如下：

- 数据类型详细介绍
- 整形在内存中的存储：原码、反码、补码
- 大小端字节序介绍及判断
- 浮点型在内存中的存储解析

### 1.数据类型详细介绍：

```c
char        //字符型数据类型(1)
short       //短整型(2)
int         //整型(4)
long        //长整型(4/8)
long long   //更长的整型(8)
float       //单精度浮点型(4)
double      //双精度浮点型(8)
```

上面列出了我们常用的基本内置类型以及它们所占存储空间的大小。

#### 类型的意义：

1. 使用这个类型我们可以知道开辟内存空间的大小（大小可以决定我们什么时候使用）；
2. 看待内存空间的视角。

##### 1.1类型的基本分类：

###### 整型家族：

```c
char
    unsigned char
    signed char
short
    unsigned short [int](size_t)
    signed short [int]
int
    unsigned int//VS2019默认取有符号的int
    signed int
long
    unsigned long [int]
    signed long [int]
long long
    unsigned long long[int]
    signed long long[int]    
```

###### Q1:char为什么也是整型呢？

A1:嗯，这个问题问的很好，char的本质是ASCII码值，是整型，归为整型家族。

###### Q2:char什么时候取signed char?什么时候取unsigned char?

A2:嗯，char到底取signed char还是unsigned char标准是未定义的，取决于编译器的实现。

###### Q3：unsigned int是无符号整型，它存在的意义何在呢？

A3：这个简单，我们生活中有些数据是不能为负数的，所以可以用unsigned int,也可写成size_t。

![image-20230424193530809](C:\Users\ZZF\AppData\Roaming\Typora\typora-user-images\image-20230424193530809.png)

##### 浮点型家族：

```C
float   //单精度浮点数
double  //双精度浮点数
```

浮点型家族：很简单，只要表示小数的就可以使用浮点型

float的精度低，存储的数值范围较小；double的精度高，存储的数据范围更大。

##### 构造类型：

等等，什么是构造类型？哈哈，很好理解就是你自己定义的类型，所以它也叫自定义类型，我们可以自己创建出新的类型。

```c
>数组类型 char arr[5]
         int arr[5]
>结构体类型 struct
>枚举类型 enum
>联合类型 union
```

有些类型大家有个印象就行，后期我还会发博客给大家讲解的，结构体我们都认识，至于枚举和联合类型，后期我会再进行讲解。

##### 指针类型：

```C
int *pi;   
char *pc;  
float* pf; 
void* pv;
```

void表示空类型（无类型）

通常应用于函数的返回类型、函数的参数、指针类型。

### 2.整型在内存中的存储

我们前面讲到创建变量是需要在内存开辟空间的。（这个空间大小取决于数据的类型）

```c
int a = 20;
int b = -20;
```

我们已经知道为a分配四个字节的空间。

那如何存储？

下面我需要引入原码、反码、补码的概念。

### 2.1原码、反码、补码

计算机的整数有三种二进制表示方法：原码、反码、补码。

三种表示方法均有**符号位**和**数值位**两部分，符号位都是用0表示"正"，用"1"表示负，而数值位

**正数的原、反、补码都相同。**

**负整数的三种表示方法各不相同。**

原码

直接把数值按照正负数的形式转换成二进制就可以得到原码。

反码

将原码的符号位不变，其他位依次按位取反就可以得到反码。

补码

补码=反码+1

**对于整型：数据在内存中存放的就是补码**

理由呢？

首先我们要知道，在计算机系统中，数值一律用补码的形式来表示和存储。原因在于，使用补码更有利于将符号位和数值域统一处理；

同时，加减法运算也可以统一处理（CPU其实只有加法器）此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。

<img src="C:\Users\ZZF\Desktop\鹏哥\start for  C\github\n.jpg" alt="n" style="zoom:25%;" />

这里我们给出a和b的原码、反码、补码

```markdown
a的原码、反码、补码 a = 20
原码:00000000 00000000 00000000 00010100
反码:00000000 00000000 00000000 00010100
补码:00000000 00000000 00000000 00010100

b的原码、反码、补码 b = -20
原码:10000000 00000000 00000000 00010100
反码:11111111 11111111 11111111 11101011
补码:11111111 11111111 11111111 11101100

a的补码：
00000000 00000000 00000000 00010100
16进制：0x 00 00 00 14

b的补码：
11111111 11111111 11111111 11101100
16进制：0x ff ff ff ec

```

什么情况？为什么是反的？难道我们算错了？

当然不是，这是因为数据存储方式有大小端，接下来，我们讲解一下大小端的知识。

### 2.2 大小端介绍

#### 什么是大小端

```markdown
大端(存储)模式,是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中；

小段(存储)模式,是指数据的低位保存在内存的低地址中，而数据的高位，保存在内存的高地址中。
```

##### 为什么有大端和小端：

```markdown
为什么会有大小端模式之分呢？这是因为在计算机系统中，我们是以字节为单位的，每个地址单元
都对应着一个字节，一个字节为8 bit。但是在C语言中除了8 bit的char之外，还有16 bit的short
型，32 bit的long型（要看具体的编译器），另外，对于位数大于8位的处理器，例如16位或者32
位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如何将多个字节安排的问题。因
此就导致了大端存储模式和小端存储模式。
例如：一个16bit 的short 型x ，在内存中的地址为0x0010 ， x 的值为0x1122 ，那么0x11 为
高字节， 0x22 为低字节。对于大端模式，就将0x11 放在低地址中，即0x0010 中， 0x22 放在高
地址中，即0x0011 中。小端模式，刚好相反。我们常用的X86 结构是小端模式，而KEIL C51 则
为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式
还是小端模式。
```

![image-20230425203009103](C:\Users\ZZF\AppData\Roaming\Typora\typora-user-images\image-20230425203009103.png)

最后呢，网上有一道大厂面试题：

请简述端字节序和小端字节序的概念，设计一个小程序来判断当前机器的字节序。(10分)



